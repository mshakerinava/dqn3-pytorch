import os
import copy
import random
import importlib
import torch

dqn = {}

import NeuralQLearner
import TransitionTable


def torchSetup(_opt):
    _opt = _opt or {}
    opt = copy.deepcopy(_opt)
    assert(opt)

    # preprocess options:
    ## convert options strings to tables
    if opt.get('pool_frms'):
        opt['pool_frms'] = str_to_dict(opt['pool_frms'])
    if opt.get('env_params'):
        opt['env_params'] = str_to_dict(opt['env_params'])
    if opt.get('agent_params'):
        opt['agent_params'] = str_to_dict(opt['agent_params'])
        opt['agent_params']['gpu']       = opt['gpu']
        opt['agent_params']['best']      = opt['best']
        opt['agent_params']['verbose']   = opt['verbose']
        if opt['network'] != '':
            opt['agent_params']['network'] = opt['network']

    ## general setup
    if 'tensorType' not in opt:
        opt['tensorType'] = torch.FloatTensor
    torch.set_default_tensor_type(opt['tensorType'])
    if opt['threads'] <= 0:
        opt['threads'] = 4
    torch.set_num_threads(opt['threads'])
    if opt['verbose'] >= 1:
        print('Torch Threads:', torch.get_num_threads())

    ## set gpu device
    if opt['gpu'] >= 0:
        if opt['gpu'] == 0:
            if 'GPU_ID' in os.environ:
                gpu_id = int(os.environ['GPU_ID'])
                torch.cuda.set_device(gpu_id)
            else:
                torch.cuda.set_device(0)
        else:
            torch.cuda.set_device(opt['gpu'])
        opt['gpu'] = torch.cuda.current_device()
        print('Using GPU device id:', opt['gpu'])
    else:
        opt['gpu'] = -1
        if opt['verbose'] >= 1:
            print('Using CPU code only. GPU device id:', opt['gpu'])


    ## set up random number generators
    # seeding Python's RNG with `opt['seed']` and setting other RNG seeds
    # to the first uniform random 32-bit ints generated by Python's RNG.
    # this is preferred because using the same seed for both generators
    # may introduce correlations; we assume that all RNGs ensure adequate
    # dispersion for different seeds.
    random.seed(opt['seed'], version=2)
    torch.manual_seed(random.randint(1, 2**32))

    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

    if opt['verbose'] >= 1:
        print('Torch Seed:', torch.initial_seed())

    return opt


def setup(_opt):
    assert(_opt)

    # preprocess options:
    ## convert options strings to tables
    _opt['pool_frms'] = str_to_dict(_opt['pool_frms'])
    _opt['env_params'] = str_to_dict(_opt['env_params'])
    _opt['agent_params'] = str_to_dict(_opt['agent_params'])
    if _opt['agent_params'].get('transition_params'):
        _opt['agent_params']['transition_params'] = str_to_table(_opt['agent_params']['transition_params'])

    ## first things first
    opt = torchSetup(_opt)

    # load training framework and environment
    framework = importlib.import_module(opt['framework'])
    assert(framework)

    gameEnv = framework.make_env(**opt, pool_type=opt['pool_frms']['type'], pool_size=opt['pool_frms']['size'])
    gameEnv.seed(random.randint(1, 2**32))
    gameActions = gameEnv.unwrapped.get_action_meanings()

    # agent options
    _opt['agent_params']['actions']   = gameActions
    _opt['agent_params']['gpu']       = _opt['gpu']
    _opt['agent_params']['best']      = _opt['best']
    if _opt['network'] != '':
        _opt['agent_params']['network'] = _opt['network']
    _opt['agent_params']['verbose'] = _opt['verbose']
    if _opt['agent_params']['state_dim'] is None:
        _opt['agent_params']['state_dim'] = gameEnv.observation_space.shape

    agent = dqn[_opt['agent']](**_opt['agent_params'])

    if opt['verbose'] >= 1:
        print('Set up Torch using these options:')
        for k, v in opt.items():
            print(k, v)

    return gameEnv, agent, opt


## other functions

def str_to_dict(s):
    if type(s) == dict:
        return s
    if not s or type(s) != str:
        return {}

    def kwargs_to_dict(**kwargs):
        return kwargs

    d = eval('kwargs_to_dict(%s)' % s)
    return d
